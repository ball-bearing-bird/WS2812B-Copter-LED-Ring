    
    // NOTES:
    // For Board layout, see: https://cdn.sparkfun.com/assets/9/c/3/c/4/523a1765757b7f5c6e8b4567.png
    // AND:
    // https://learn.sparkfun.com/tutorials/pro-micro--fio-v3-hookup-guide/hardware-overview-pro-micro
    
    
    // INCLUDES:
    #include <FastLED.h>  // Library for handling Neopixel LED's
    // FastLED library located here:   https://github.com/FastLED/FastLED/releases
    
    
    // CONSTANTS - NEOPIXELS:
    // How many LED's are in your Neopixel LED strip?
    #define NUM_leds 4 // 56  // The number of LED's in the NeoPixel strip.
    
    // For led chips like Neopixels, which have a data line, ground, and power, you just
    // need to define PIN_NEOPIXEL_LED_DATA_LINE.  For led chipsets that are SPI based (four wires - data, clock,
    // ground, and power), like the LPD8806, define both PIN_NEOPIXEL_LED_DATA_LINE and CLOCK_PIN.
    #define PIN_NEOPIXEL_LED_DATA_LINE 4  // The Pin on the Micro Pro board that the LED string data line is connected to.
    // #define CLOCK_PIN 13
    
    // Set up the block of memory that will be used for storing and manipulating the led data:
    // This creates an array, called "ledArray", of size NUM_leds:
    CRGB ledArray[NUM_leds];
    
    
    // CONSTANTS - DEFINE PULSE WIDTH MODULATION (PWM):
    // http://www.camelsoftware.com/firetail/blog/radio/reading-pwm-signals-from-a-remote-control-receiver-with-arduino/
    // It’s possible to read PWM signals using hardware interrupts. A hardware interrupt is a 
    // signal that is generated by the hardware that literally interrupts the processor. 
    // With Arduino, hardware interrupts can be generated by a pin changing value, going LOW, 
    // going HIGH, rising or falling. 
    // The processor responds to interrupts by suspending its current activity and handling 
    // the interrupt with an interrupt handler. After the interrupt handler has returned, 
    // the processor resumes its previous activity.
    
    // Unlike the easy way, reading PWM inputs with interrupts allows the processor to continue 
    // with other tasks except for that very brief moment when an interrupt is handled.
    // To read PWM inputs we must know when a pin goes HIGH and LOW, and so we are only really 
    // interested in CHANGE interrupts. When a PWM pin goes HIGH, a timer is started. 
    // When the pin goes LOW, we can measure the pulse time by checking how much time has passed.
    
    // Arduino has the function attachInterrupt(), which allows us to supply an interrupt handler
    // for a particular event and pin number. 
    
    // The micros() function Returns the number of microseconds since the Arduino board began
    // running the current program. This number will overflow (go back to zero), after 
    // approximately 70 minutes.
    
    // The micros() function isn’t particularly precise on AVR based Arduinos. Gabriel Staples 
    // over at electricrcaircraftguy.blogspot.com has written a library for precision timing. 
    // It’s available here: http://electricrcaircraftguy.blogspot.com/2014/02/Timer2Counter-more-precise-Arduino-micros-function.html
    
    // NOTE:
    // The Pro Micro has five external interrupts, which allow you to instantly trigger a function
    // when a pin goes either high or low (or both). If you attach an interrupt to an
    // interrupt-enabled pin, you’ll need to know the specific interrupt that pin triggers: 
    // pin 3 maps to interrupt 0, 
    // pin 2 is interrupt 1,
    // pin 0 is interrupt 2,
    // pin 1 is interrupt 3, and
    // pin 7 is interrupt 4.
    
    // Define the arduino pin that is receiving the Pulse Width Modulation (PWM) signal:
    #define PIN_PWM_SOURCE 7 // Which causes an interrupt on Pin 4 (PIN_NEOPIXEL_LED_DATA_LINE).
    
    // "timer_start" defines the time when the the PIN_PWM_SOURCE pin goes from LOW to HIGH:
    volatile unsigned long timer_start;
    
    // "pulse_time" is the length of time that the pin is HIGH:
    volatile int pulse_time; 
    
    // This is the time that the last interrupt occurred. 
    // You can use this to determine if your receiver has a signal or not.
    volatile int last_interrupt_time;
    
    
    // CONSTANTS - FLOODLIGHT:
    #define PIN_FLOODLIGHT_SWITCH 10 // Define the pin that turns the floodlight off & on.
    
    // CONSTANTS - LOOP() DELAY TIME:
    #define delayTime 100  // Delay time constant (1000 = 1 second)
    
    
    // CONSTANTS - MATH:
    int randomNumber = 1;
    
    
    // CONSTANTS - CYLON EYE:
    unsigned char leftRight = 1;                   // start off going to the RIGHT	
    unsigned char centre_Pos_Cylon_Eye = (int)round(NUM_leds/2);        // Centre position of Cylon Eye
    
    
    // FUNCTIONS:
    // SETUP FUNCTION():
    void setup()
    {
       // This tells the library that there's a strand of NEOPIXEL's on pin PIN_NEOPIXEL_LED_DATA_LINE:
       // and that these ledArray will use the LED array: "ledArray"
       FastLED.addLeds<NEOPIXEL, PIN_NEOPIXEL_LED_DATA_LINE>(ledArray, NUM_leds);
       
       // Initialise serial output (Open the serial port at 115200 bps):
       Serial.begin(115200);
       
       Serial.print("Hello world!");  // prints hello with ending line break 
       
       // Set up the digital pin (PIN_PWM_SOURCE):
       pinMode(PIN_PWM_SOURCE, INPUT);
       
       timer_start = 0;
       
       // Create an "attachInterrupt" so as that when the pin with the PWM source changes, 
       // the calcsignal() function is called:
       attachInterrupt(PIN_NEOPIXEL_LED_DATA_LINE, calcSignal, CHANGE); // Attach the interrupt handler
       
       // Set the digital pin #10 (PIN_FLOODLIGHT_SWITCH) as output:
       pinMode(PIN_FLOODLIGHT_SWITCH, OUTPUT);
    }
    
    
    // LOOP FUCNTION():
    // The primary loop: 
    void loop() 
    {  
      // If you want your program to change "functions" based on the "pulse_time" value, then use:
      // if (pulse_time < value) // where value = 1000 --> 2000 microSeconds
      // {
      //    Do_Function_01();
      // }
      // else
      // {
      //    Do_Function_02();
      // }
      
      // But in this case, we just call the one function:
      cylonEye_02();
      
      
      // OTHER FUNCTION CALLS (Use One at a time instead of above):
      // cylonEye_01();
      // assignRandomColours();
      // mapPotentiometer();
      // sequentiallyDarkerRed();
      // flashLEDZeroOffOn();
      
      // Update the LED's:
      FastLED.show();
      
      // Set the loop Update time:
      delay(4*delayTime);
    }
        

// The function "calcSignal()" is the interrupt handler:
    void calcSignal()
    {
       // NOTE:
       // Your in this function because the Pro Micro Arduino board recorded that there was a 
       // change on the Pulse Width Modulation signal coming from pin PIN_PWM_SOURCE.
       
       // The micros() function Returns the number of microseconds since the Arduino board began
       // running the current program. This number will overflow (go back to zero), after 
       // approximately 70 minutes.
       
       // Record the current board time:
       last_interrupt_time = micros();
       
       // If the pin PIN_PWM_SOURCE has gone "HIGH", set "timer_start":
       if (digitalRead(PIN_PWM_SOURCE) == HIGH)
       {
          timer_start = micros();
       }
       // Otherwise, the pin has gone "LOW":
       else
       {
          // Only worry about this if the timer has actually started
          if (timer_start > 0)
          {
              // Record the PWM "pulse_time" duration:
              pulse_time = ((volatile int)micros() - timer_start);
            
              // Reset the timer:
              timer_start = 0;
          }
       }
//       Serial.println("last_interrupt_time:");
//       Serial.println(last_interrupt_time);
//       Serial.println("timer_start:");
//       Serial.println(timer_start);
//       Serial.println("pulse_time:");
//       Serial.println(pulse_time);
    }
             
    
    void cylonEye_01()
    {
      // We display a moving cylon eye, and use the PWM signal to continuously change
      // the colour of the "eye":
      
      // First, clear the existing led values
      FastLED.clear();
      
      // Note: "centre_Pos_Cylon_Eye" always starts in the middle of the NEO PIXEL array.
      if (leftRight == 1) // If true, then Cylon slash needs to move to the right
      {
        centre_Pos_Cylon_Eye++;
        if (centre_Pos_Cylon_Eye >= (NUM_leds - 1))
        {
          leftRight = 0;
        }
      }
      else
      {
        centre_Pos_Cylon_Eye--;
        if (centre_Pos_Cylon_Eye == 0)
        {
          leftRight = 1;
        }
      }
      
      // Now set the LED VALUES:
      if (pulse_time < 1256)
      {
        // Adjust pulse_time if less than 1000:
        if (pulse_time < 1000)
        {
          pulse_time = 1000;
        }
        ledArray[centre_Pos_Cylon_Eye - 1].r = (pulse_time - 1000)/4;
        ledArray[centre_Pos_Cylon_Eye].r = pulse_time - 1000;
        ledArray[centre_Pos_Cylon_Eye + 1].r = (pulse_time - 1000)/4;

      }
      if ( (pulse_time >= 1256) && (pulse_time < 1512) )
      {
        ledArray[centre_Pos_Cylon_Eye - 1].g = (pulse_time - 1256)/4;
        ledArray[centre_Pos_Cylon_Eye].g = pulse_time - 1256;
        ledArray[centre_Pos_Cylon_Eye + 1].g = (pulse_time - 1256)/4;
      }
      if ( (pulse_time >= 1512) && (pulse_time < 1768) )
      {
        ledArray[centre_Pos_Cylon_Eye - 1].b = (pulse_time - 1512)/4;
        ledArray[centre_Pos_Cylon_Eye].b = pulse_time - 1512;
        ledArray[centre_Pos_Cylon_Eye + 1].b = (pulse_time - 1512)/4;
      }
      if (pulse_time >= 1768)
      {
        // Adjust pulse_time if greater than 2000:
        if (pulse_time > 2000)
        {
          pulse_time = 2000;
        }
        for (int i = 0; i < NUM_leds; i++)
        {
          ledArray[centre_Pos_Cylon_Eye - 1].r = (pulse_time - 1746)/4;
          ledArray[centre_Pos_Cylon_Eye - 1].g = (pulse_time - 1746)/4;
          ledArray[centre_Pos_Cylon_Eye - 1].b = (pulse_time - 1746)/4;
          ledArray[centre_Pos_Cylon_Eye].r = (pulse_time - 1746);
          ledArray[centre_Pos_Cylon_Eye].g = (pulse_time - 1746);
          ledArray[centre_Pos_Cylon_Eye].b = (pulse_time - 1746);
          ledArray[centre_Pos_Cylon_Eye + 1].r = (pulse_time - 1746)/4;
          ledArray[centre_Pos_Cylon_Eye + 1].g = (pulse_time - 1746)/4;
          ledArray[centre_Pos_Cylon_Eye + 1].b = (pulse_time - 1746)/4;
        }
      }  
      
      // OTHER FUNCTION CALLS (Use One at a time instead of above):
      // cylonEye_01();
      // assignRandomColours();
      // mapPotentiometer();
      // sequentiallyDarkerRed();
      // flashLEDZeroOffOn();
      
      // Update the LED's:
      FastLED.show();
      
      // Set the loop Update time:
      delay(4*delayTime);
    }
    
    
    
    
    void cylonEye_02()
    {
      // We display a moving cylon eye, and use the PWM signal to continuously change
      // the colour of the "eye":
      
      // First, clear the existing led values
      FastLED.clear();
      
      // Set the Floodlight Diode Pin to "OFF":
      digitalWrite(PIN_FLOODLIGHT_SWITCH, LOW);
      
      // Note: "centre_Pos_Cylon_Eye" always starts in the middle of the NEO PIXEL array.
      if (leftRight == 1) // If true, then Cylon slash needs to move to the right
      {
        centre_Pos_Cylon_Eye++;
        if (centre_Pos_Cylon_Eye >= (NUM_leds - 1))
        {
          leftRight = 0;
        }
      }
      else
      {
        centre_Pos_Cylon_Eye--;
        if (centre_Pos_Cylon_Eye == 0)
        {
          leftRight = 1;
        }
      }
      
      // Now set the LED VALUES:
      if (pulse_time < 1256)
      {
        ledArray[centre_Pos_Cylon_Eye - 1].r = (pulse_time - 1000)/4;
        ledArray[centre_Pos_Cylon_Eye].r = pulse_time - 1000;
        ledArray[centre_Pos_Cylon_Eye + 1].r = (pulse_time - 1000)/4;
      }
      if ( (pulse_time >= 1256) && (pulse_time < 1512) )
      {
        ledArray[centre_Pos_Cylon_Eye - 1].g = (pulse_time - 1256)/4;
        ledArray[centre_Pos_Cylon_Eye].g = pulse_time - 1256;
        ledArray[centre_Pos_Cylon_Eye + 1].g = (pulse_time - 1256)/4;
        
        // Set the Floodlight Diode Pin to "ON":
        digitalWrite(PIN_FLOODLIGHT_SWITCH, HIGH);
      }
      if ( (pulse_time >= 1512) && (pulse_time < 1768) )
      {
        ledArray[centre_Pos_Cylon_Eye - 1].b = (pulse_time - 1512)/4;
        ledArray[centre_Pos_Cylon_Eye].b = pulse_time - 1512;
        ledArray[centre_Pos_Cylon_Eye + 1].b = (pulse_time - 1512)/4;
      }
      if (pulse_time >= 1768)
      {
        // Adjust pulse_time of greater than 2000:
        if (pulse_time > 2000)
        {
          pulse_time = 2000;
        }
        for (int i = 0; i < NUM_leds; i++)
        {
          ledArray[centre_Pos_Cylon_Eye - 1].r = (pulse_time - 1746)/4;
          ledArray[centre_Pos_Cylon_Eye - 1].g = (pulse_time - 1746)/4;
          ledArray[centre_Pos_Cylon_Eye - 1].b = (pulse_time - 1746)/4;
          ledArray[centre_Pos_Cylon_Eye].r = (pulse_time - 1746);
          ledArray[centre_Pos_Cylon_Eye].g = (pulse_time - 1746);
          ledArray[centre_Pos_Cylon_Eye].b = (pulse_time - 1746);
          ledArray[centre_Pos_Cylon_Eye + 1].r = (pulse_time - 1746)/4;
          ledArray[centre_Pos_Cylon_Eye + 1].g = (pulse_time - 1746)/4;
          ledArray[centre_Pos_Cylon_Eye + 1].b = (pulse_time - 1746)/4;
        }
      }  
      
      // OTHER FUNCTION CALLS (Use One at a time instead of above):
      // cylonEye_01();
      // assignRandomColours();
      // mapPotentiometer();
      // sequentiallyDarkerRed();
      // flashLEDZeroOffOn();
      
      // Update the LED's:
      FastLED.show();
      
      // Set the loop Update time:
      delay(4*delayTime);
    }
    
    

    void assignRandomColours()
    {
      // First, clear the existing led values
      FastLED.clear();
      
      // Assign random colours to each successive Neo Pixel:
      for (int i = 0; i < NUM_leds; i++)
      {
          ledArray[i].r = random8(0, 25);   //int(255 * (i / (NUM_leds - 1)));
          ledArray[i].g = random8(0, 25);
          ledArray[i].b = random8(0, 25);
      } 
      
      // Update the LED's:
      FastLED.show();
  
      // Set the loop Update time:
      delay(delayTime);
    }
    
    
    void mapPotentiometer()
    {
      // USE A POTENTIOMETER TO CONTROL HOW MANY NEO-PIXELS ARE LIT UP:
      // Say you have a potentiometer hooked up to your arduino on analog pin 2. 
      // That gives a value from 0-1023.
      // What if we used the value from there to decide how many ledArray to have on?
      // We can use the arduino map function to go from 0-1023 to 0-NUM_leds.
      // Arduino map function: http://www.arduino.cc/en/Reference/map
      // map(value, fromLow, fromHigh, toLow, toHigh)
      
      int val = analogRead(2);
      int numledArrayToLight = map(val, 0, 1023, 0, NUM_leds);
      
      // First, clear the existing led values
      FastLED.clear();
      
      for(int led = 0; led < numledArrayToLight; led++) { 
          ledArray[led] = CRGB::Blue;
          // Can change the LED colours here.
          // Could add a function here, depending on the mapped value
      }
      
      // Update the LED's:
      FastLED.show();
  
      // Set the loop Update time:
      delay(delayTime);
      
      // Now you have something that will change the number of ledArray that are
      // based on what your knob is set to.
    }
    
    
    
    void sequentiallyDarkerRed()
    {
      // Set each sequential LED to a darker Red colour and then cycle back:
      for(int i = 0; i < NUM_leds; i++) {
          ledArray[i].r = 255 - 85*i;   //int(255 * (i / (NUM_leds - 1)));
          ledArray[i].g = 0;
          ledArray[i].b = 0;
          //ledArray[i] = CRGB::Blue;
          
          // Update the LED's:
          FastLED.show();
      
          // clear this led for the next time around the loop:
          ledArray[i] = CRGB::Black;
          
          // Set the loop Update time:
          delay(1000);
      }
    }
    
    
    
    void flashLEDZeroOffOn()
    {
      // Turn the first led red for 1 second:
      ledArray[0] = CRGB::Red; 
      // Update the LED's:
      FastLED.show();
      // Set the loop Update time:
      delay(delayTime); 
      
      // Set the first led back to black for 1 second
      ledArray[0] = CRGB::Black;
      
      // Update the LED's:
      FastLED.show();
      // Set the loop Update time:
      delay(delayTime);
    }
