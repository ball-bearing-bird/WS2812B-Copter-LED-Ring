    
    // NOTES:
    // FastLED library located here:   https://github.com/FastLED/FastLED/releases
    // For Board layout, see: https://cdn.sparkfun.com/assets/9/c/3/c/4/523a1765757b7f5c6e8b4567.png
    
    // INCLUDES:
    #include <FastLED.h>
    
    
    // DEFINE CONSTANTS:
    // How many leds in your strip?
    #define NUM_LEDS 4 // 60  // The number of LED's in the NeoPixel strip.
    
    // For led chips like Neopixels, which have a data line, ground, and power, you just
    // need to define DATA_PIN.  For led chipsets that are SPI based (four wires - data, clock,
    // ground, and power), like the LPD8806, define both DATA_PIN and CLOCK_PIN
    #define DATA_PIN 4  // The Pin on the Micor Pro board that the LED string is connected to.
    #define CLOCK_PIN 0 // 13
    
    // Define LED delay time:
    #define delayTime 100  // Delay time constant - Used for strobing the LEDs
    
    // PULSE WIDTH MODULATION:
    // http://www.camelsoftware.com/firetail/blog/radio/reading-pwm-signals-from-a-remote-control-receiver-with-arduino/
    // It’s possible to read PWM signals using hardware interrupts. A hardware interrupt is a 
    // signal that is generated by the hardware that literally interrupts the processor. 
    // With Arduino, hardware interrupts can be generated by a pin changing value, going LOW, 
    // going HIGH, rising or falling. 
    // The processor responds to interrupts by suspending its current activity and handling 
    // the interrupt with an interrupt handler. After the interrupt handler has returned, 
    // the processor resumes its previous activity.
    
    // Unlike the easy way, reading PWM inputs with interrupts allows the processor to continue 
    // with other tasks except for that very brief moment when an interrupt is handled.
    // To read PWM inputs we must know when a pin goes HIGH and LOW, and so we are only really 
    // interested in CHANGE interrupts. When a PWM pin goes HIGH, a timer is started. 
    // When the pin goes LOW, we can measure the pulse time by checking how much time has passed.
    
    // Arduino has the function attachInterrupt(), which allows us to supply an interrupt handler
    // for a particular event and pin number. The micros() function allows us to measure the time,
    // in microseconds, between the pin going HIGH and returning to LOW.
    
    // The micros() function isn’t particularly precise on AVR based Arduinos. Gabriel Staples 
    // over at electricrcaircraftguy.blogspot.com has written a library for precision timing. 
    // It’s available here: http://electricrcaircraftguy.blogspot.com/2014/02/Timer2Counter-more-precise-Arduino-micros-function.html
    
    // Define the arduino pin that is receiving the Pulse Width Modulation (PWM) signal:
    #define PWM_SOURCE 10 
    
    
    // Micros when the pin goes HIGH:
    volatile unsigned long timer_start;
    
    // The difference between timer_start and micros() is the length of time that the pin was 
    // HIGH - the PWM pulse length:
    volatile int pulse_time; 
    
    // This is the time that the last interrupt occurred. 
    // You can use this to determine if your receiver has a signal or not.
    volatile int last_interrupt_time;
    
    //calcSignal is the interrupt handler
    void calcSignal()
    {
       // Record the interrupt time so that we can tell if the receiver has a signal from the transmitter:
       last_interrupt_time = micros();

       // If the pin has gone HIGH, record the microseconds since the Arduino started up
       if (digitalRead(PWM_SOURCE) == HIGH)
       {
          timer_start = micros();
       }
       // Otherwise, the pin has gone LOW:
       else
       {
          // Only worry about this if the timer has actually started
          if (timer_start > 0)
          {
              // Record the pulse time:
              pulse_time = ((volatile int)micros() - timer_start);
            
              // Restart the timer:
              timer_start = 0;
          }
       }
    }

    // NOW DO ALL THE NORMAL ARDUINO STUFF:
        
    // Set up the block of memory that will be used for storing and manipulating the led data:
    // This creates an array, called "leds", of size NUM_LEDS:
    CRGB leds[NUM_LEDS];
    
    // Setup the LEDs:
    void setup() {
       // This tells the library that there's a strand of NEOPIXEL's on pin DATA_PIN:
       // and that these LEDs will use the LED array: "leds"
       FastLED.addLeds<NEOPIXEL, DATA_PIN>(leds, NUM_LEDS);
       
       timer_start = 0;
       attachInterrupt(PWM_SOURCE, calcSignal, CHANGE);
       Serial.begin(115200);
    }
   
    // The primary loop that controls the LEDs: 
    void loop() { 
      if (pulse_time < 500)
      {
        leds[1].r = 100;   //int(255 * (i / (NUM_LEDS - 1)));
        FastLED.show(); 
      }
      else
      {
        leds[1].r = 255;   //int(255 * (i / (NUM_LEDS - 1)));
        FastLED.show(); 
      }
        
        /*
        // Turn the first led red for 1 second:
        leds[1] = CRGB::Red; 
        FastLED.show(); 
        delay(delayTime); 
        
        // Set the first led back to black for 1 second
        leds[1] = CRGB::Black;
        FastLED.show();
        delay(delayTime);
        */
        
        
        // ASSIGN RANDOM COLOURS TO EACH OF THE LED's:
        /*
        for(int i = 0; i < NUM_LEDS; i++) {
            leds[i].r = random8(0, 255);   //int(255 * (i / (NUM_LEDS - 1)));
            leds[i].g = random8(0, 255);
            leds[i].b = random8(0, 255);
            FastLED.show(); 
            delay(delayTime); 
        }
        */      
        
        /*       
        // Set each sequential LED to a darker Red colour and then cycle back:
        for(int i = 0; i < NUM_LEDS; i++) {
            leds[i].r = 255 - 85*i;   //int(255 * (i / (NUM_LEDS - 1)));
            leds[i].g = 0;
            leds[i].b = 0;
            //leds[i] = CRGB::Blue;
            FastLED.show();
            
            
            // clear this led for the next time around the loop
            leds[i] = CRGB::Black;
            delay(1000);
        }
        */
        
        
        /*
        // Say you have a potentiometer hooked up to your arduino on analog pin 2. 
        // That gives a value from 0-1023.
        // What if we used the value from there to decide how many leds to have on?
        // We can use the arduino map function to go from 0-1023 to 0-NUM_LEDS.
        // Arduino map function: http://www.arduino.cc/en/Reference/map
        // map(value, fromLow, fromHigh, toLow, toHigh)
        
        int val = analogRead(2);
        int numLedsToLight = map(val, 0, 1023, 0, NUM_LEDS);

        // First, clear the existing led values
        FastLED.clear();
        for(int led = 0; led < numLedsToLight; led++) { 
            leds[led] = CRGB::Blue;
            // Can change the LED colours here.
            // Could add a function here, depedning on the mapped value
        }
        FastLED.show();
        
        // Now you have something that will change the number of leds that are
        // based on what your knob is set to.
        */
    }
    
    
    
    
    
